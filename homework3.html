<html>
  <head>
    <meta charset="UTF-8">
    <style>
     body {
         font-family: Menlo;
         font-size: 12px;
     }

     pre {
         border: 1px solid black;
         border-radius: 2px;
         margin: 0;
         padding: 4px;
     }

     pre > code {
         color: #bfbfbf;
     }


     .col {
         width: 40%;
         min-width: 600px;
         margin: 1em;
         float: left
     }

     canvas.paper {
         border: 1px solid gray;
     }

    </style>
    <link rel='stylesheet' type='text/css' href='webppl-editor.css'>
    <link rel='stylesheet' type='text/css' href='webppl-viz.css'>
    <script src="webppl-editor.js"></script>
    <script src="jquery.js"></script>
    <script src="paper.js"></script>
    <script src="draw.js"></script>
	<script src="webppl-viz.js"></script>
  </head>
  <body>




<!-- 
Instructions:

Place text in <h1>Example</h1> to make headers. Replace 1 with larger numbers for subheaders.

To insert a code box, type <pre><code></code></pre>. If you want the box pre-filled, you can put anything you want in the middle, as in 

<pre><code>flip() ? flip(.7) : flip(.1)</code></pre>

Happy coding! --!>





<!-- ONLY EDIT BELOW THIS --!>

<h3> Part 1: Let's get acquainted with some distributions </h3>

<h4> The categorical distribution </h4>
<p>
The distribution  has two parameters: two vectors, <b>vs</b> and <b>ps</b>, which have to the same length.
</p>
<p>
The easiest way to think of the  distribution <b> Categorical({vs,ps})</b> is to imagine drawing a marble from a bag of colored marbles. Say you have a bag where half the marbles are blue, a third are red, and a sixth are green. Then <b>vs</b> would be the vector <b>["blue", "red", "green"]</b> and <b>ps</b> would be <b>[1/2, 1/3, 1/6]</b>. The distribution <b> Cat({vs,ps})</b> tells you the probability of drawing a marble of each color.

<b>Exercise:</b>
Play around with the categorical distribution in the codebox below until you feel comfortable with it.

<pre><code>
var vs = ["good", "bad", "ugly"]
var ps = [1/2, 1/3, 1/6]
viz(Categorical({vs:vs, ps:ps}))
categorical({vs:vs, ps:ps})
</code></pre>

<h4> The Dirichlet distribution </h4>
The Dirichlet distribution, <b> Dirichlet(alpha) </b> is a probability distribution on vectors that could serve as <b>ps</b> for the categorical distribution -- i.e. n-dimensional vectors with nonnegative entries that sum to 1. We can think of Dirichlet as being a distribution on bags.
</p>
<p> 
The n-dimensional parameter <b>alpha</b> affects which vectors are more likely to be drawn. If alpha is just (1,1,1,...,1), then all vectors (i.e. all kinds of bags) are equally likely. If you start with the prior <b>Dirichlet(1,1,1)</b>, set <b>vs</b> to be <b>["blue", "red", "green"]</b>, and draw a red marble from your bag, then your posterior on the distribution of marbles in the bag is <b>Dirichlet(1,2,1)</b>. If you then draw 60 blue marbles, 39 red marbles, and 20 green marbles, then you posterior on the distribution of marbles in the bag is <b>Dirichlet(61,41,21)</b>. That means you're pretty confident that the <b>ps</b> vector of the bag is close to <b>[1/2,1/3,16]</b> based on the data you observed.
</p>

<p>
In the code below, the function <b>makeBag</b> returns a "bag of marbles": a categorical probability distribution where the <b>vs</b> are 5 colors, and the vector of probabilities 
<b>ps = [q1, q2,...,q5]</b> is drawn from <b>Dirichlet(1,1,1,..1)</b>.  In other words, we have no idea what the color proportions are in this bag.
</p>
<p>
<b> makeBag</b> has an input, which it remembers via <b>mem</b>. The input doesn't affect what <b>makeBag</b> does, but if you call it with the same input a second time, it produces the same distribution.
</p>
<b> Exercise: </b>play with the code and make sure it makes sense to you. 


<pre><code>
var colors = ['black', 'blue', 'green', 'orange', 'red'];

var makeBag = mem(function(bagName){     
    var colorProbs = dirichlet(ones([colors.length, 1]))
    return Categorical({vs: colors, ps: colorProbs})
  })


var drawMarbles = function(bagName, numDraws){
  var bag = makeBag(bagName);      // bag is a Categorical probability distribution
  return repeat(numDraws, function(){return sample(bag)});
}

// the first three graphs should look similar, since you're drawing marbles from
// the same bag. The last one should be totally different.
viz(drawMarbles('bagA', 100))
viz(drawMarbles('bagA', 100))
viz(drawMarbles('bagA', 100))
viz(drawMarbles('bagB', 100))
</code></pre>


The function <b> drawMarbles</b> above produces draws from a random bag of marbles. 
This is our prior for where colored marbles come from. 

<p>
Now let's condition on some data! In the code below, we ask ourselves: 
if I've seen some marbles from a bag, how do I update my probability 
distribution on which marble will be picked next?
</p>

<b> Exercise: </b>play with the code and make sure it makes sense to you. 

<pre><code>
var colors = ['black', 'blue', 'green', 'orange', 'red'];

var observedData = [
{bag: 'bag1', draw: 'blue'},
{bag: 'bag1', draw: 'blue'},
{bag: 'bag1', draw: 'black'},
{bag: 'bag1', draw: 'blue'},
{bag: 'bag1', draw: 'blue'},
{bag: 'bag1', draw: 'blue'},
  
{bag: 'bag2', draw: 'blue'},
{bag: 'bag2', draw: 'green'},
{bag: 'bag2', draw: 'blue'},
{bag: 'bag2', draw: 'blue'},
{bag: 'bag2', draw: 'blue'},
{bag: 'bag2', draw: 'red'},
  
{bag: 'bag3', draw: 'blue'},
{bag: 'bag3', draw: 'orange'}
]

var predictives = Infer({method: 'MCMC', samples: 20000}, function(){
  var makeBag = mem(function(bagName){
    var colorProbs = dirichlet(ones([colors.length, 1])) 
// "ones([colors.length, 1])" means a vector of all 1's of the same length as the vector "colors"   
    return Categorical({vs: colors, ps: colorProbs})
  })

 // The observation function that we apply to each element of data 
  var obsFn = function(datum){
    observe(makeBag(datum.bag), datum.draw)
  }
  // This is how you apply a function to each element of a list
  mapData({data: observedData}, obsFn)

  return {bag1: sample(makeBag('bag1')),
          bag2: sample(makeBag('bag2')),
          bag3: sample(makeBag('bag3')),
          bagN: sample(makeBag('bagN'))}
})

viz.marginals(predictives)
</code></pre>


<h4> The Gamma distributions </h4>
<p>
The family of Gamma distributions are distributions on nonnegative numbers. When you need to pick a "random positive number", you usually use a Gamma. But which one?
</p>
<p>
The Gamma distribution has two parameters: <b>shape</b> and <b>scale</b>. The scale literally just rescales the x-axis; the shape actually changes the shape. The best way to see this is to play with some <a href= https://www.desmos.com/calculator/hxdo9v3bg8> Gammas on Desmos</a>.
(In the demo, <b>a</b> is the shape, <b>b</b> is the scale, and the curves are not normalized; all of them need to be multiplied by some constant so that it integrates to 1.)
</p>
<p>
The mean of <b>Gamma(shape:a, scale: b)</b> is <b>ab</b>. So when we want to choose a "random positive number" that is, on average, around 1 but could easily be much bigger or much smaller, we often use <b> Gamma(2,0.5)</b> as a prior. Since this is a pretty arbitrary choice, it is important in this case to check that the results don't depend too much on the choice of <b> a</b> and <b>b</b>; if you have enough data, your results should not be significantly affected. 
</p>

<h3> Part 2: Hierarchical models </h3> 

Let;s get back to our bags of marbles. What if we suspect that the distributions of colors in the different bags are somehow related? Maybe they come from the same factory; or maybe the bags represent different students in the same class; or are somehow produced by similar processes.

We can model this using a hierarchical model:
<ul>
<li> At the top is the Dirichlet distribution from which all the probability distributions in the bags are drawn. (We can think of this as the "factory" that produces the bags.)
This distribution has a vector of parameters <b>alpha</b>, which has two important properties:
<ul>
<li> The relative size of its entries, which we call its <b>bias</b>. Large differences in size would make our bags generally biased toward one color or another. We can think of bias as a vector whose entries sum to 1. 
We have no prior opinion about the bias of our "factory", so we draw it from <b>Dirichlet(1,1...1)</b>. 
(This is an unusual use of Dirichlet: usually we use it to sample probabilities, The bias is not a probability, but it's a vector of nonnegative numbers that sum to 1, so Dirichlet is convenient.)</li>
<li> The sum of the entries of <b>alpha</b>, which we call the <b>strength</b>. When the strength is  high, the probability distributions for all the bags will be very similar to each other (and to the bias of the Dirichlet). </li>
</ul>
<li> The next layer in the model are the bags themselves. Each bag corresponds to a distributions of colors (q1, q2, q3, q4, q5), drawn from Dirichlet(alpha). </li>
<li> The final layer are the marbles you draw from the bags, with a different Multinomial distribution for each bag. This is the only layer that you actually get to observe -- everything else is inferred. </li>
</ul>

<p>
Using such a model, let's see what we can infer about the bags from different kinds of data... 
</p>
<p>
<b> Exercise: BEFORE YOU RUN THE CODE BELOW </b>, look at the data and try to guess what sorts of things the model will infer about bags 1,2, and 3, and also about a random bag from which we have seen no data yet.
</p>


<pre><code>
var colors = ['black', 'blue', 'green', 'orange', 'red'];

var observedData = [
{bag: 'bag1', draw: 'blue'},
{bag: 'bag1', draw: 'blue'},
{bag: 'bag1', draw: 'black'},
{bag: 'bag1', draw: 'blue'},
{bag: 'bag1', draw: 'blue'},
{bag: 'bag1', draw: 'blue'},
  
{bag: 'bag2', draw: 'blue'},
{bag: 'bag2', draw: 'green'},
{bag: 'bag2', draw: 'blue'},
{bag: 'bag2', draw: 'blue'},
{bag: 'bag2', draw: 'blue'},
{bag: 'bag2', draw: 'red'},
  
{bag: 'bag3', draw: 'blue'},
{bag: 'bag3', draw: 'orange'}
]

var predictives = Infer({method: 'MCMC', samples: 20000}, function(){
  // Construct the global Dirichlet distribution that all the bags come from
  // What is our prior on its bias? Simply that all outcomes that sum to 1 are 
  // equally likely. So we use Dir(1,1,1,1,1).
  var bias = dirichlet(ones([5, 1]))
  // What about strength? This has to be a positive number. 
  // The usual distribution people use when they need to pick a 
  // "random positive numbers is gamma(2,0.5). If we wanted to assume more strength,
  // we could use a larger scale parameter.
  var strength = gamma(2,0.5)  

  var global_parameters = T.mul(bias, strength)
  // T.mul(d,x) multiplies the probabilities in `d` by x

  var makeBag = mem(function(bag){
    var colorProbs = dirichlet(global_parameters)
    return Categorical({vs: colors, ps: colorProbs})
  })

  var obsFn = function(datum){
    observe(makeBag(datum.bag), datum.draw)
  }

  mapData({data: observedData}, obsFn)

  return {bag1: sample(makeBag('bag1')),
          bag2: sample(makeBag('bag2')),
          bag3: sample(makeBag('bag3')),
          bag4: sample(makeBag('bag4')),
          bagN: sample(makeBag('bagN')),
          strength: strength}
});

viz.marginals(predictives)
</code></pre>

<p> <b> Exercise </b> Now try predicting what will happen when you replace the data you're 
conditioning on by the following.
</p>

<pre><code>
var NewData1 = [
{bag: 'bag1', draw: 'blue'}, {bag: 'bag1', draw: 'blue'}, {bag: 'bag1', draw: 'blue'},
{bag: 'bag1', draw: 'blue'}, {bag: 'bag1', draw: 'blue'}, {bag: 'bag1', draw: 'blue'},
{bag: 'bag2', draw: 'green'}, {bag: 'bag2', draw: 'green'}, {bag: 'bag2', draw: 'green'},
{bag: 'bag2', draw: 'green'}, {bag: 'bag2', draw: 'green'}, {bag: 'bag2', draw: 'green'},
{bag: 'bag3', draw: 'red'}, {bag: 'bag3', draw: 'red'}, {bag: 'bag3', draw: 'red'},
{bag: 'bag3', draw: 'red'}, {bag: 'bag3', draw: 'red'}, {bag: 'bag3', draw: 'red'},
{bag: 'bag4', draw: 'orange'}]

var NewData2 = [
{bag: 'bag1', draw: 'blue'}, {bag: 'bag1', draw: 'red'}, {bag: 'bag1', draw: 'green'},
{bag: 'bag1', draw: 'black'}, {bag: 'bag1', draw: 'red'}, {bag: 'bag1', draw: 'blue'},
{bag: 'bag2', draw: 'green'}, {bag: 'bag2', draw: 'red'}, {bag: 'bag2', draw: 'black'},
{bag: 'bag2', draw: 'black'}, {bag: 'bag2', draw: 'blue'}, {bag: 'bag2', draw: 'green'},
{bag: 'bag3', draw: 'red'}, {bag: 'bag3', draw: 'green'}, {bag: 'bag3', draw: 'blue'},
{bag: 'bag3', draw: 'blue'}, {bag: 'bag3', draw: 'black'}, {bag: 'bag3', draw: 'green'},
{bag: 'bag4', draw: 'orange'}]

</code></pre>
<p> <b> Exercise:</b> Try playing with the Gamma parameters in the distribution for <b>strength</b>.
See how it affects the results. Also, see how the data affect the posterior distribution of
<b>strength.</b> (You can use either <b>viz</b> separately to see what your Gamma prior for strength looks like.)







<!-- ONLY EDIT ABOVE THIS --!>




</body>

<script>

   // load scratch pad contents

   $("#ed-scratch code").text(localStorage.getItem('ed-scratch'));

   var scratchComp;
   $("pre").map(function(i,el) {
       var comp = wpEditor.setup(el, {language: "webppl"});
       if (el.id == 'ed-scratch') {
           scratchComp = comp;
       }
   });

   // save scratch pad contents

   window.onbeforeunload = function() { localStorage.setItem('ed-scratch', scratchComp.getCode()) }

   var throwString = function() { throw 'string error' };
  </script>


  <script src="//s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-v0.9.7.js"></script>
  
</html>
